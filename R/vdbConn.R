#' Connect to a VDB
#' 
#' Connect to a VDB
#' 
#' @param path The location of the VDB directory on the local file system
#' 
#' #details This locates the VDB connection info (located in *vdbPrefix*/conn.R) and loads it into the environment
#' 
#' @return nothing
#' 
#' @author Ryan Hafen
#' 
#' @seealso \code{\link{vdbMakeConnTemplate}}, \code{\link{vdbInit}}
#' @export
vdbConnect <- function(path=NULL) {
   if(!file.exists(file.path(path, "conn.R"))) {
      stop(paste("There is not a conn.R file in ", path, ".  This directory either hasn't been initialized (using vdbInit()), or the 'conn.R' file is simply missing.  A template can be generated by calling vdbMakeConnTemplate(\"", path, "\").", sep=""))
   }
   
   # TODO: validate

   source(file.path(path, "conn.R"))
}

#' Create a Template VDB Connection File
#' 
#' Create a template VDB connection file
#' 
#' @param vdbPrefix The location of the VDB directory on the local file system
#' @param name name of the VDB
#' @param overwrite Overwrite any existing 'conn.R' file
#' 
#' @details This is called by vdbInit() so it should rarely need to be used.
#' 
#' @return nothing
#' 
#' @author Ryan Hafen
#' 
#' @seealso \code{\link{vdbConnect}}, \code{\link{vdbInit}}
#' @export
vdbMakeConnTemplate <- function(vdbPrefix, name="myVDB", overwrite=FALSE) {

   defaultPars <- list(
      vdbName = name,
      vdbPrefix = vdbPrefix,
      defaultStorage = "local",
      hdfsPrefix = "/tmp",
      hadoopBundleDir = NULL,
      HADOOP_CONF_DIR = NULL,
      HADOOP_HOME = NULL,
      HADOOP_LIBS = NULL,
      mongoHost = "localhost",
      mongoName = "",
      mongoUser = "",
      mongoPass = "", 
      ip = "123.45.67.8",
      user = "someuser",
      url = "http://something.com", 
      port = "81",
      appDir = "/var/shiny-server/www", 
      vdbPrefix = "/scratch/vdbTest" 
   )

   if(file.exists(file.path(vdbPrefix, "conn.R")) && !overwrite) {
      message(paste("A conn.R already exists in ", vdbPrefix, ".  Will not overwrite unless overwrite=TRUE", sep=""))
   } else {
      vdbUpdateConn(defaultPars)
   }
}

#' Update VDB Connection Options
#' 
#' Update VDB connection options
#' 
#' @param conn A list with names the correspond to VDB connection options and the corresponding settings
#' 
#' @details It is easier to simply edit the conn.R file in your VDB directory
#' 
#' @return nothing
#' 
#' @author Ryan Hafen
#' 
#' @seealso \code{\link{vdbConnect}}, \code{\link{vdbInit}}
#' @export
vdbUpdateConn <- function(conn) {
   pkgPath <- system.file(package="trelliscope")
   
   a <- readLines(file.path(pkgPath, "connTemplate.R"))
   
   parLines <- which(grepl("@@", a))
   parNames <- sapply(a[parLines], function(x) gsub(".*@@(.*)@@.*", "\\1", x), USE.NAMES=FALSE)

   listInd <- sapply(conn, is.list)
   listNames <- names(conn)[listInd]

   pars <- unlist(conn)
   for(nm in listNames) {
      names(pars) <- gsub(paste("^", nm, "\\.", sep=""), "", names(pars))
   }
   pars <- as.list(pars)

   for(i in seq_along(parNames)) {
      curVal <- pars[[parNames[i]]]
      if(is.null(curVal)) {
         curVal <- "NULL"
      } else {
         curVal <- paste("\"", curVal, "\"", sep="")      
      }

      a[parLines[i]] <- gsub("@@.*@@", curVal, a[parLines[i]])
   }
   
   # make sure there are no commas in the last uncommented parLine
   lastUncmt <- max(which(!grepl("^[ \t]+#", a[parLines])))
   a[parLines[lastUncmt]] <- gsub(",", "", a[parLines[lastUncmt]])
   
   cat(paste(a, collapse="\n"), file=file.path(conn$vdbPrefix, "conn.R"))
}



